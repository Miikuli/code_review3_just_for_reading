#ifndef CALC_TREE_H
#define CALC_TREE_H

#include <string>   // Для работы со строками
#include <vector>   // Для использования динамических массивов (векторов)
#include <fstream>  // Для работы с файлами (чтение и запись)

/**
 * @file CalcTree.h
 * @brief Заголовочный файл для проекта CalcTree, предназначенного для обработки
 * арифметических выражений, представленных в инфиксной форме.
 *
 * Содержит объявления структуры узла дерева выражения и прототипы функций
 * для выполнения различных операций, таких как лексический анализ, построение
 * дерева, вычисление значения, преобразование структуры дерева и вывод дерева
 * в файл в определенном формате.
 */

/**
 * @struct Node
 * @brief Представляет узел в абстрактном синтаксическом дереве (AST)
 * арифметического выражения. Каждый узел может содержать оператор,
 * число или переменную 'x', а также указатели на левого и правого потомков.
 */
struct Node {
    std::string value; ///< Значение узла: оператор (+, -, *, /, %, ^), число (в виде строки) или "x".
    Node *left;      ///< Указатель на левого потомка узла.
    Node *right;     ///< Указатель на правого потомка узла.

    /**
     * @brief Конструктор для создания нового узла дерева.
     * @param val Строковое значение, которое будет храниться в узле.
     */
    Node(std::string val);
};

/**
 * @brief Определяет приоритет арифметических операторов.
 * Операторы с более высоким приоритетом выполняются первыми.
 * @param op Строковое представление оператора (+, -, *, /, %, ^).
 * @return Целое число, представляющее приоритет оператора:
 * 1 для '+' и '-', 2 для '*', '/', '%', 3 для '^', 0 для других случаев.
 */
int get_priority(const std::string& op);

/**
 * @brief Проверяет, является ли заданная строка представлением целого числа.
 * @param s Строка, которую необходимо проверить.
 * @return true, если строка состоит только из цифр, false в противном случае.
 */
bool is_number(const std::string& s);

/**
 * @brief Проверяет, является ли заданная строка одним из поддерживаемых
 * арифметических операторов.
 * @param s Строка, которую необходимо проверить.
 * @return true, если строка является одним из операторов (+, -, *, /, %, ^),
 * false в противном случае.
 */
bool is_operator(const std::string& s);

/**
 * @brief Выполняет лексический анализ (токенизацию) входного арифметического
 * выражения. Разбивает строку на отдельные лексемы (числа, операторы,
 * скобки, переменная 'x').
 * @param expression Строка, содержащая арифметическое выражение в инфиксной форме.
 * @return Вектор строк, где каждый элемент является отдельной лексемой.
 */
std::vector<std::string> tokenize(const std::string& expression);

/**
 * @brief Строит абстрактное синтаксическое дерево (AST) выражения из
 * последовательности токенов в постфиксной (обратной польской) нотации.
 * @param postfix_tokens Вектор строк, представляющих токены выражения в постфиксной форме.
 * @return Указатель на корень построенного дерева выражения.
 */
Node* build_expression_tree(std::vector<std::string>& postfix_tokens);

/**
 * @brief Преобразует последовательность токенов из инфиксной нотации
 * в постфиксную (обратную польскую) нотацию, которая удобна для
 * построения дерева выражения. Использует алгоритм "сортировочной станции".
 * @param infix_tokens Вектор строк, представляющих токены выражения в инфиксной форме.
 * @return Вектор строк, представляющих токены выражения в постфиксной форме.
 */
std::vector<std::string> infix_to_postfix(const std::vector<std::string>& infix_tokens);

/**
 * @brief Рекурсивно вычисляет значение арифметического выражения, представленного
 * в виде дерева.
 * @param node Указатель на корень (или подкорень) дерева выражения.
 * @param x_value Целочисленное значение, которое необходимо подставить вместо
 * переменной 'x'.
 * @return Целочисленный результат вычисления выражения (или подвыражения).
 */
int evaluate(Node* node, int x_value);

/**
 * @brief Рекурсивно обходит дерево выражения и преобразует поддеревья,
 * имеющие вид "x * A", в вид "A * x", где A - любое поддерево.
 * Это преобразование может быть полезно для определенных видов оптимизации
 * или приведения дерева к определенной канонической форме.
 * @param node Указатель на корень (или подкорень) дерева, которое необходимо
 * преобразовать.
 * @return Указатель на корень (или подкорень) преобразованного дерева.
 */
Node* transform_tree(Node* node);

/**
 * @brief Вспомогательная рекурсивная функция для печати дерева выражения
 * в многострочном формате с отступами, представляющими уровни дерева.
 * @param node Указатель на текущий узел дерева, который необходимо напечатать.
 * @param level Текущий уровень глубины в дереве (начиная с 0 для корня).
 * @param outfile Ссылка на поток вывода в файл, куда будет записано представление дерева.
 */
void print_tree_helper(Node* node, int level, std::ofstream& outfile);

/**
 * @brief Инициирует печать дерева выражения в файл, вызывая вспомогательную
 * рекурсивную функцию. Корневой узел передается с начальным уровнем 0.
 * @param root Указатель на корень дерева выражения, которое необходимо напечатать.
 * @param outfile Ссылка на поток вывода в файл.
 */
void print_tree(Node* root, std::ofstream& outfile);

/**
 * @brief Рекурсивно освобождает память, выделенную для узлов дерева выражения.
 * Важно вызывать эту функцию после использования дерева, чтобы избежать
 * утечек памяти.
 * @param node Указатель на корень (или подкорень) дерева, память которого
 * необходимо освободить.
 */
void delete_tree(Node* node);

#endif // CALC_TREE_H
